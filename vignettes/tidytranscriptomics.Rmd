---
title: "RNAseq-R-tidyverse"
author:
  - Maria Doyle, Peter MacCallum Cancer Centre^[<maria.doyle at petermac.org>]
  - Stefano Mangiola, Walter and Eliza Hall Institute^[<mangiola.s at wehi.edu.au>]
output: rmarkdown::html_vignette
bibliography: "`r file.path(system.file(package='RNAseqRtidyverse', 'vignettes'), 'tidytranscriptomics.bib')`"
vignette: >
  %\VignetteIndexEntry{RNAseq-R-tidyverse}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{css, echo = FALSE}
# Formatting for polls
.poll {
background-color: #fff4d4;
}
.poll code {
	background-color: #fff4d4;
}
```


This workshop will present how to perform analysis of RNA sequencing data following the tidy data paradigm [@wickham2014tidy]. The tidy data paradigm provides a standard way to organise data values within a dataset, where each variable is a column, each observation is a row, and data is manipulated using an easy-to-understand vocabulary. Most importantly, the data structure remains consistent across manipulation and analysis functions.

This can be achieved for RNA sequencing data with the [tidybulk](https://stemangiola.github.io/tidybulk/), [tidyHeatmap](https://stemangiola.github.io/tidyHeatmap) [@mangiola2020tidyheatmap] and [tidyverse](https://www.tidyverse.org/) [@wickham2019welcome] packages. The tidybulk package provides a tidy data structure and a modular framework for bulk transcriptional analyses. tidyHeatmap provides a tidy implementation of ComplexHeatmap. These packages are part of the tidytranscriptomics suite that introduces a tidy approach to RNA sequencing data representation and analysis


### Acknowledgements
This material was adapted from an R for RNA sequencing workshop first run [here](http://combine-australia.github.io/2016-05-11-RNAseq/).

```{r, echo=FALSE, out.width = "100px"}
knitr::include_graphics("../inst/vignettes/tidybulk_logo.png")
```


## Introduction
Measuring gene expression on a genome-wide scale has become common practice over the last two decades or so, with microarrays predominantly used pre-2008. With the advent of next generation sequencing technology in 2008, an increasing number of scientists use this technology to measure and understand changes in gene expression in often complex systems. As sequencing costs have decreased, using RNA sequencing to simultaneously measure the expression of tens of thousands of genes for multiple samples has never been easier. The cost of these experiments has now moved from generating the data to storing and analysing it.

There are many steps involved in analysing an RNA sequencing dataset. Sequenced reads are aligned to a reference genome, then the number of reads mapped to each gene can be counted. This results in a table of counts, which is what we perform statistical analyses on in R. While mapping and counting are important and necessary tasks, today we will be starting from the count data and showing how differential expression analysis can be performed in a friendly way using the Bioconductor package, tidybulk.


First, letâ€™s load all the packages we will need to analyse the data. 

_Note: you should load the *tidybulk* library after the tidyverse core packages for best integration._

```{r message=FALSE, warning=FALSE}
# load libraries

# tidyverse core packages
library(tibble)
library(dplyr)
library(tidyr)
library(readr)
library(stringr)
library(ggplot2)

# tidyverse-friendly packages
library(plotly)
library(ggrepel)
library(GGally)
library(tidyHeatmap)
library(tidybulk)
```

Plot settings. Set the colours and theme we will use for our plots.

```{r}
# Use colourblind-friendly colours
friendly_cols <- dittoSeq::dittoColors()

# Set theme
custom_theme <-
  list(
    scale_fill_manual(values = friendly_cols),
    scale_color_manual(values = friendly_cols),
    theme_bw() +
      theme(
        panel.border = element_blank(),
        axis.line = element_line(),
        panel.grid.major = element_line(size = 0.2),
        panel.grid.minor = element_line(size = 0.1),
        text = element_text(size = 12),
        legend.position = "bottom",
        strip.background = element_blank(),
        axis.title.x = element_text(margin = margin(t = 10, r = 10, b = 10, l = 10)),
        axis.title.y = element_text(margin = margin(t = 10, r = 10, b = 10, l = 10)),
        axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1)
      )
  )
```

### Setting up the data

Here we will perform RNA-Seq analysis using data from a breast cancer research study, from the paper by [Fu et al. 2015](https://www.ncbi.nlm.nih.gov/pubmed/25730472), GEO code GSE60450. This study examined gene expression in basal and luminal cells from mice at different stages of mammary gland development (virgin, pregnant and lactating). There are 2 samples per group and 6 groups, 12 samples in total.

We will be using the tidyverse pipe `%>%`. This 'pipes' the output from the command on the left into the command on the right/below. Using the pipe is not essential but it reduces the amount of code we need to write when we have multiple steps (as we'll see later). It also can make the steps clearer and easier to see. For more details on the pipe see [here](https://r4ds.had.co.nz/pipes.html).

```{r}
# import RNA-seq counts
seqdata <- read_tsv("https://ndownloader.figshare.com/files/5057929?private_link=1d788fd384d33e913a2a")

# import sample information
sampleinfo <- read_tsv("https://ndownloader.figshare.com/files/5999832?private_link=1d788fd384d33e913a2a")
```

Take a look at the data.

```{r}
seqdata
```

```{r}
sampleinfo
```

Shorten the sample names to the first 7 characters in the counts file columns.

```{r}
countdata <- rename_with(seqdata, ~ str_sub(.x, 1, 7), starts_with("MCL"))
```

Add gene symbols

```{r}
countdata <- mutate(countdata, symbol = AnnotationDbi::mapIds(org.Mm.eg.db::org.Mm.eg.db, 
                                          keys = as.character(EntrezGeneID), 
                                          keytype = "ENTREZID", 
                                          column="SYMBOL", 
                                          multiVals = "first"))
```


Convert the counts into long format (tidy format).

```{r}
counts_long <- 
	pivot_longer(countdata, cols = starts_with("MCL"), names_to = "sample", values_to = "counts") 

# take a look
counts_long
```



```{r}
sampleinfo_formatted <- sampleinfo %>%
    
    # make column called Group by combining the CellType and Status columns
    unite("Group", CellType:Status, sep=".", remove=FALSE) %>%
    
    # replace the . in the SampleName column with - so can join to counts
    mutate(SampleName=str_replace(SampleName, "\\.", "-"))
```

Join the counts and sampleinfo 
```{r}
counts_annot <- left_join(counts_long, sampleinfo_formatted, by = c("sample" = "SampleName"))
```

```{r}
# convert to tidybulk tibble
counts_tt <-
  counts_annot %>%
  mutate(EntrezGeneID = as.character(EntrezGeneID)) %>%
  tidybulk(.sample=sample, .transcript=EntrezGeneID, .abundance=counts)
```


The `counts_airway` object contains information about genes and samples, the first column has the Ensembl gene identifier, the second column has the sample identifier and the third column has the gene transcription abundance. The abundance is the number of reads aligning to the gene in each experimental sample. The remaining columns include sample-wise information. The dex column tells us whether the samples are treated or untreated and the cell column tells us what cell line they are from.
We can shorten the sample names. We can remove the SRR1039 prefix that's present in all of them, as shorter names can fit better in some of the plots we will create. We can use `mutate()` together with `str_replace()` to remove the SRR1039 string from the sample column.
We can get the gene symbols for these Ensembl gene ids using the Bioconductor annotation package for human, `org.Hs.eg.db` and add them as a column using `mutate` again.
With tidyverse, all above steps can be linked with the `%>%`, as shown below. This has the benefits that
* no temporary variables need to be created
* less typing is required
* the steps can be seen more clearly.
```{r eval=FALSE}
# setup data workflow
counts_tt <-
  airway %>%
  tidybulk() %>%
  mutate(sample = str_remove(sample, "SRR1039")) %>%
  mutate(symbol = AnnotationDbi::mapIds(org.Hs.eg.db::org.Hs.eg.db,
    keys = as.character(feature),
    keytype = "ENSEMBL",
    column = "SYMBOL",
    multiVals = "first"
  ))
# take a look
counts_tt
```

From this tidybulk tibble, we can perform differential expression analysis with the tidybulk package.

## Filtering lowly transcribed genes  
Genes with very low counts across all libraries provide little evidence for differential expression and they can interfere with some of the statistical approximations that are used later in the pipeline. They also add to the multiple testing burden when estimating false discovery rates, reducing power to detect differentially expressed genes. These genes should be filtered out prior to further analysis.

We can perform the filtering using tidybulk `keep_abundant` or `identify_abundant`. These functions can use the *edgeR* `filterByExpr` function described in [@law2016rna] to automatically identify the genes with adequate abundance for differential expression testing. By default, this will keep genes with ~10 counts in a minimum number of samples, the number of the samples in the smallest group. In this dataset the smallest group size is four (as we have four dex-treated samples versus four untreated). Alternatively, we could use `identify_abundant` to identify which genes are abundant or not (TRUE/FALSE), rather than just keeping the abundant ones. 

```{r}
# Filtering counts
counts_filtered <- counts_tt %>% keep_abundant(factor_of_interest = Group)

# take a look
counts_filtered
```
After running `keep_abundant` we have a column called `.abundant` containing TRUE  (`identify_abundant` would have TRUE/FALSE).

## Scaling counts to normalise

Scaling of counts, normalisation, is performed to eliminate uninteresting differences between samples due to sequencing depth or composition. A more detailed explanation can be found [here](https://hbctraining.github.io/DGE_workshop/lessons/02_DGE_count_normalization.html). In the tidybulk package the function `scale_abundance` generates scaled counts, with scaling factors calculated on abundant (filtered) transcripts and applied to all transcripts. We can choose from different normalisation methods. Here we will use the default, edgeR's trimmed mean of M values (TMM), [@robinson2010scaling]. TMM normalisation (and most scaling normalisation methods) scale relative to one sample.

```{r}
# Scaling counts
counts_scaled <- counts_filtered %>% scale_abundance()

# take a look
counts_scaled
```

After we run `scale_abundance` we should see some columns have been added at the end. The `counts_scaled` column contains the scaled counts.

We can visualise the difference of abundance distributions before and after scaling. As tidybulk output is compatible with tidyverse, we can simply pipe it into standard tidyverse functions such as `filter`, `pivot_longer` and `ggplot`. We can also take advantage of ggplot's `facet_wrap` to easily create multiple plots.

```{r out.width = "70%"}
counts_scaled %>%

  # Reshaping        
  pivot_longer(cols = c("counts", "counts_scaled"), names_to = "source", values_to = "abundance") %>%
    
  # Plotting
  ggplot(aes(x = sample, y = abundance + 1, fill = Group)) +
  geom_boxplot() +
  geom_hline(aes(yintercept = median(abundance + 1)), colour = "red") +
  facet_wrap(~source) +
  scale_y_log10() +
  theme_bw()
```

In this dataset the distributions of the counts are not very different to each other before scaling but scaling does make the distributions more similar. If we saw a sample with a very different distribution we may need to investigate it.


## Exploratory analyses

### Dimensionality reduction

By far, one of the most important plots we make when we analyse RNA sequencing data are principal-component analysis (PCA) or multi-dimensional scaling (MDS) plots. We reduce the dimensions of the data to identify the greatest sources of variation in the data. A principal components analysis is an example of an unsupervised analysis, where we don't need to specify the groups. If your experiment is well controlled and has worked well, what we hope to see is that the greatest sources of variation in the data are the treatments/groups we are interested in. It is also an incredibly useful tool for quality control and checking for outliers. We can use the `reduce_dimensions` function to calculate the dimensions.


```{r}
# Get principal components
counts_scal_MDS <-
  counts_scaled %>%
  reduce_dimensions(method = "MDS", scale=FALSE)
```


This joins the result to the counts object.

```{r}
# Take a look
counts_scal_MDS
```
For plotting, we can select just the sample-wise information with `pivot_sample`.

```{r}
# take a look
counts_scal_MDS %>% pivot_sample()
```

We can now plot the reduced dimensions.

```{r out.width = "70%"}
# MDS plot
counts_scal_MDS %>%
  pivot_sample() %>%
  ggplot(aes(x = Dim1, y = Dim2, colour = CellType, shape = Status)) +
  geom_point() +
  geom_text_repel(aes(label = sample), show.legend = FALSE) +
  custom_theme
```

The samples separate by treatment on PC1 which is what we hope to see. PC2 separates the N080611 cell line from the other samples, indicating a greater difference between that cell line and the others.


### Hierarchical clustering with heatmaps

An alternative to principal component analysis for examining relationships between samples is using hierarchical clustering. Heatmaps are a nice visualisation to examine hierarchical clustering of your samples. tidybulk has a simple function we can use, `keep_variable`, to extract the most variable genes which we can then plot with tidyHeatmap.

```{r out.width = "70%"}
counts_scal_MDS %>%

  # extract 500 most variable genes
  keep_variable(.abundance = counts_scaled, top = 500) %>%

  # create heatmap
  heatmap(
    .column = sample,
    .row = EntrezGeneID,
    .value = counts_scaled,
    transform = log1p
  ) %>%
  add_tile(CellType) %>%
  add_tile(Status)
```

In the heatmap we can see the samples cluster into two groups, treated and untreated, for three of the cell lines, and the cell line (N080611) again is further away from the others.

Tidybulk enables a simplified way of generating a clustered heatmap of variable genes. Compare the code below for tidybulk versus a base R method.

**base R using edgeR**
```{r eval=FALSE}
# Example code, no need to run

library(edgeR)
dgList <- SE2DGEList(airway)
group <- factor(dgList$samples$dex)
keep.exprs <- filterByExpr(dgList, group = group)
dgList <- dgList[keep.exprs, , keep.lib.sizes = FALSE]
dgList <- calcNormFactors(dgList)
logcounts <- cpm(dgList, log = TRUE)
var_genes <- apply(logcounts, 1, var)
select_var <- names(sort(var_genes, decreasing = TRUE))[1:500]
highly_variable_lcpm <- logcounts[select_var, ]
colours <- c("#440154FF", "#21908CFF", "#fefada")
col.group <- c("red", "grey")[group]
gplots::heatmap.2(highly_variable_lcpm, col = colours, trace = "none", ColSideColors = col.group, scale = "row")
```


## Differential expression

*tidybulk* integrates several popular methods for differential transcript abundance testing: the edgeR quasi-likelihood [@chen2016reads] (tidybulk default method), edgeR likelihood ratio [@mccarthy2012differential], limma-voom [@law2014voom] and DESeq2 [@love2014moderated]. A common question researchers have is which method to choose. With tidybulk we can easily run multiple methods and compare.

We give `test_differential_abundance` our tidybulk counts object and a formula, specifying the column that contains our groups to be compared. If all our samples were from the same cell line, and there were no additional factors contributing variance such as batch differences, we could use the formula `~ dex`. However, each treated and untreated sample is from a different cell line so we add the cell line as an additional factor `~ dex + cell`. 

```{r message=FALSE}
de_all <-

  counts_scal_MDS %>%

  # edgeR QLT
  test_differential_abundance(
    ~ 0 + Group,
    method = "edgeR_quasi_likelihood",
    prefix = "edgerQLT_",
    .contrasts =  c("Groupbasal.pregnant - Groupbasal.lactate"),
    omit_contrast_in_colnames = TRUE
  ) %>%

  # edgeR LRT
  test_differential_abundance(
    ~ 0 + Group,
    method = "edgeR_likelihood_ratio",
    prefix = "edgerLR_",
    .contrasts =  c("Groupbasal.pregnant - Groupbasal.lactate"),
    omit_contrast_in_colnames = TRUE
  ) %>%

  # limma-voom
  test_differential_abundance(
    ~ 0 + Group,
    method = "limma_voom",
    prefix = "voom_",
    .contrasts =  c("Groupbasal.pregnant - Groupbasal.lactate"),
    omit_contrast_in_colnames = TRUE
  ) %>%

  # DESeq2
  test_differential_abundance(
    ~ 0 + Group,
    method = "deseq2",
    prefix = "deseq2_",
    .contrasts =  list(c("Group", "basal.lactate", "basal.pregnant")),
    omit_contrast_in_colnames = TRUE
  )

# take a look

de_all
```

This outputs the columns from each method such as log-fold change (logFC), false-discovery rate (FDR) and probability value (p-value). logFC is log2(treated/untreated).

### Comparison of methods

We can visually compare the significance for all methods. We will notice that there is some difference between the methods.

```{r message=FALSE}
de_all %>%
  pivot_transcript() %>%
  select(edgerQLT_PValue, edgerLR_PValue, voom_P.Value, deseq2_pvalue, EntrezGeneID) %>%
  ggpairs(1:4)
```

In order to decide which genes are differentially expressed, we usually take a cut-off of 0.05 on the FDR (or adjusted P value), NOT the raw p-value. This is because we are testing many genes (multiple testing), and the chances of finding differentially expressed genes is very high when you do that many tests. Hence we need to control the false discovery rate, which is the adjusted p-value column in the results table. What this means is that if 100 genes are significant at a 5% false discovery rate, we are willing to accept that 5 will be false positives. 

We can count how many differentially expressed genes there are, for example with the edgeR QLT method. We'll filter on FDR 0.05.

```{r}
de_all %>%
  filter(edgerQLT_FDR < 0.05) %>%
  summarise(num_de = n_distinct(EntrezGeneID))
```


```{poll_7 class.source="poll"}
Which method detects the most differentially abundant transcripts, p value adjusted for multiple testing <  0.05 (FDR, adj.P.Val, padj)?
```

_Note: Some of the methods produce columns with different names for similar outputs. If you wish to make these consistent you can do that with tidyverse `rename`. For example, to rename the p value adjusted columns you could run below._

```{r eval=FALSE}
de_all %>% rename(deseq2_FDR = deseq2_padj, voom_FDR = voom_adj.P.Val)
```

We can select some of the transcripts that look different between methods in the plot using the [*tidygate*](https://github.com/stemangiola/tidygate) package. We can then investigate these transcripts, for example, by visualising their counts.

With tidygate, we can interactively draw gates to select points we want using `gate`. We specify which columns we want to plot in the scatterplot, and how many gates we want to draw. We can also specify the opacity if we want to make it easier to see overlapping points.

```{r, eval=FALSE}
de_gate <-
  de_all %>%

  tidygate::gate(
    EntrezGeneID,
    edgerQLT_PValue,
    deseq2_pvalue,
    opacity = 0.3,
    how_many_gates = 2
  )
```

We then click to draw gates around the points we want, for example as shown in the screenshot below.

```{r, echo=FALSE}
knitr::include_graphics("../inst/vignettes/comparison_different_DE_methods_gates.png")
```

That will add a column called gate, specifying which gate the points (transcripts) are in.

```{r echo=FALSE}
# using pre-selected gates just to render the html version of this document
de_gate <-
  de_all %>%

  tidygate::gate(
    EntrezGeneID,
    edgerQLT_PValue,
    deseq2_pvalue,
    gate_list = RNAseqRtidyverse::de_gate_gates
  )

de_gate
```

We can check how many transcripts we've got in each gate.

```{r}
de_gate %>%
  pivot_transcript() %>%
  count(gate)
```

We can now select the transcripts from our two gates i.e. more significant in edgeR (gate 1) and more significant in DESeq2 (gate 2) and visualise the counts for each sample in the treated and untreated groups.

```{r eval=FALSE}
de_gate %>%

  # Filter for transcripts within the gates
  filter(gate > 0) %>%

  # Rename for clarity
  mutate(gate = case_when(
    gate == 1 ~ "more in edgeR",
    gate == 2 ~ "more in DESeq2",
    TRUE ~ gate
  )) %>%

  # Order the plots for the transcripts
  mutate(EntrezGeneID = forcats::fct_reorder(EntrezGeneID, edgerQLT_PValue, min)) %>%

  # Plot
  ggplot(aes(dex, counts_scaled, color = gate)) +
  geom_point() +
  facet_wrap(~EntrezGeneID, scale = "free_y", ncol = 4) +
  custom_theme
```

We could also check the log fold changes for these genes and see, for example, that DESeq2 produces a more conservative logFC statistic for the gene `ENSG00000104725`.

```{r eval=FALSE}
de_gate %>%
  pivot_transcript() %>%
  filter(EntrezGeneID == "ENSG00000104725") %>%
  select(edgerQLT_logFC, deseq2_log2FoldChange)
```

### Single method

If we just wanted to run one differential testing method we could do that. The default method is edgeR quasi-likelihood.

```{r}
counts_de <- counts_scal_MDS %>%
    test_differential_abundance(~ 0 + Group,
                                .contrasts =  c("Groupbasal.pregnant - Groupbasal.lactate"),
                                omit_contrast_in_colnames = TRUE)
```

Tidybulk enables a simplified way of performing an RNA sequencing differential expression analysis (with the benefit of smoothly integrating with ggplot2 and other tidyverse packages). Compare the code for a tidybulk edgeR analysis versus standard edgeR below.

**standard edgeR**
```{r eval=FALSE}
# Example code, no need to run

library(edgeR)
dgList <- SE2DGEList(airway)
group <- factor(dgList$samples$dex)
keep.exprs <- filterByExpr(dgList, group = group)
dgList <- dgList[keep.exprs, , keep.lib.sizes = FALSE]
dgList <- calcNormFactors(dgList)
cell <- factor(dgList$samples$cell)
design <- model.matrix(~ group + cell)
dgList <- estimateDisp(dgList, design)
fit <- glmQLFit(dgList, design)
qlf <- glmQLFTest(fit, coef=2)
```


## Plots after testing for differentially expressed

We'll extract the symbols for a few top genes (by P value) to use in some of the plots we will make.

```{r}
topgenes_symbols <-
  counts_de %>%
  pivot_transcript() %>%
  arrange(PValue) %>%
  head(6) %>%
  pull(symbol)
```

### Volcano plots

Volcano plots are a useful genome-wide plot for checking that the analysis looks good. Volcano plots enable us to visualise the significance of change (p-value) versus the fold change (logFC). Highly significant genes are towards the top of the plot. We can also colour significant genes (e.g. genes with false-discovery rate < 0.05)

```{r out.width = "70%"}
# volcano plot, minimal
counts_de %>%
  ggplot(aes(x = logFC, y = PValue, colour = FDR < 0.05)) +
  geom_point() +
  scale_y_continuous(trans = "log10_reverse") +
  custom_theme
```

A more informative plot, integrating some of the packages in tidyverse.

```{r out.width = "70%", warning=FALSE}
counts_de %>%
  pivot_transcript() %>%

  # Subset data
  mutate(significant = FDR < 0.05 & abs(logFC) >= 2) %>%
  mutate(symbol = ifelse(symbol %in% topgenes_symbols, as.character(symbol), "")) %>%

  # Plot
  ggplot(aes(x = logFC, y = PValue, label = symbol)) +
  geom_point(aes(color = significant, size = significant, alpha = significant)) +
  geom_text_repel() +

  # Custom scales
  custom_theme +
  scale_y_continuous(trans = "log10_reverse") +
  scale_color_manual(values = c("black", "#e11f28")) +
  scale_size_discrete(range = c(0, 2))
```

### Stripcharts

Before following up on the differentially expressed genes with further lab work, it is also recommended to have a look at the expression levels of the individual samples for the genes of interest. We can use stripcharts to do this. These will help show if expression is consistent amongst replicates in the groups.

With stripcharts we can see if replicates tend to group together and how the expression compares to the other groups. We'll also add a box plot to show the distribution. Tidyverse faceting makes it easy to create a plot for each gene.

```{r out.width = "70%"}
strip_chart <-
  counts_scaled %>%

  # extract counts for top differentially expressed genes
  filter(symbol %in% topgenes_symbols) %>%

  # make faceted stripchart
  ggplot(aes(x = Group, y = counts_scaled + 1, fill = Group, label = sample)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~symbol) +
  scale_y_log10() +
  custom_theme

strip_chart
```


## Interactive Plots

A really nice feature of using tidyverse and ggplot2 is that we can make interactive plots quite easily using the plotly package. This can be very useful for exploring what genes or samples are in the plots. We can make interactive plots directly from our ggplot2 object (strip_chart). Having `label` in the `aes` is useful to visualise the identifier of the data point (here the sample id) or other variables when we hover over the plot.

We can also specify which parameters from the `aes` we want to show up when we hover over the plot with `tooltip`.

```{r, out.width = "70%", warning=FALSE}
strip_chart %>% ggplotly(tooltip = c("label", "y"))
```


## Automatic bibliography

Tidybulk provides a handy function called `get_bibliography` that keeps track of the references for the methods used in your tidybulk workflow. The references are in BibTeX format and can be imported into your reference manager.

```{r}
get_bibliography(counts_de)
```


# Contributing
If you want to suggest improvements for this workshop or ask questions, you can do so as described [here](https://github.com/mblue9/RNAseq-R-tidyverse/blob/master/CONTRIBUTING.md).

# Reproducibility
Record package and version information with `sessionInfo`

```{r}
sessionInfo()
```

# References
